```python
def findKthBit(n: int, k: int) -> str:
    """
    Finds the kth bit in the binary string Sn generated by the given rules.

    The string Sn is formed as follows:
    S1 = "0"
    Si = Si-1 + "1" + reverse(invert(Si-1)) for i > 1

    Args:
        n: The integer representing the string Sn.
        k: The 1-indexed position of the bit to find.

    Returns:
        The kth bit of Sn as a string ("0" or "1").
    """
    # invert_count tracks whether the final bit needs to be inverted.
    # 0 means no inversion (or an even number of inversions),
    # 1 means invert (or an odd number of inversions).
    invert_count = 0

    # We simulate the recursive process iteratively, starting from Sn and going down to S1.
    # In each step, we determine which segment of Si the k-th bit falls into
    # (first part, middle '1', or reversed/inverted part of Si-1).
    while n > 1:
        # Calculate the length of Sn-1. The length of Si is 2^i - 1.
        # The middle character '1' in Si is at index 2^(i-1) (1-indexed).
        # We use a bit shift for 2^(n-1), which is 1 << (n - 1).
        mid_idx = 1 << (n - 1)

        if k == mid_idx:
            # If k is the middle bit, it's always '1' before considering any inversions.
            # Apply the accumulated invert_count.
            # If invert_count is 0, the bit remains '1'. If 1, it becomes '0'.
            return "1" if invert_count == 0 else "0"
        elif k < mid_idx:
            # If k is in the first part (Sn-1), we continue searching in Sn-1 with the same k.
            n -= 1
            # The invert_count doesn't change as this segment is Sn-1 itself.
        else: # k > mid_idx
            # If k is in the third part (reverse(invert(Sn-1))).
            # First, update k to its corresponding position in Sn-1.
            # The k-th bit of Sn is the (2^n - k)-th bit of Sn-1, and that bit is inverted.
            # This effectively "mirrors" k around the midpoint of Sn and also toggles the bit.
            k = (1 << n) - k
            n -= 1
            # Since this segment corresponds to 'invert(Sn-1)', we need to toggle the invert_count.
            invert_count = 1 - invert_count
    
    # Base case: n == 1. S1 = "0".
    # At this point, n is 1, and k must be 1 (as k is guaranteed to be valid).
    # The first bit of S1 is "0".
    # Apply the final accumulated invert_count to this base bit.
    return "0" if invert_count == 0 else "1"
```